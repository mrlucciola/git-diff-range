#!/bin/sh

resolve_defaults() {
  cd "$REPO_PATH"

  [ -z "$END_REF" ] && END_REF="HEAD"

  if [ -z "$START_REF" ]; then
    PREV_COMMIT=$(git rev-parse "$END_REF^" 2>/dev/null || true)
    if [ -z "$PREV_COMMIT" ]; then
      echo "Error: No previous commit found for '$END_REF'" >&2
      exit 1
    fi
    START_REF="$PREV_COMMIT"
  fi
}
#!/bin/sh

run_git_diff() {
  cd "$REPO_PATH"
  DIFF_OUTPUT=$(git diff "$START_REF" "$END_REF")
}
#!/bin/sh

handle_output() {
  if [ -n "$OUT_PATH" ]; then
    echo "$DIFF_OUTPUT" >"$OUT_PATH"
    [ "$VERBOSE" = "true" ] && echo "$DIFF_OUTPUT"
  else
    echo "$DIFF_OUTPUT"
  fi
}
#!/bin/sh

parse_args() {
  START_REF=""
  END_REF=""
  REPO_PATH="$(pwd)"
  OUT_PATH=""
  VERBOSE="false"

  while [ $# -gt 0 ]; do
    case "$1" in
    -start-ref)
      START_REF="$2"
      shift 2
      ;;
    -end-ref)
      END_REF="$2"
      shift 2
      ;;
    -repo-path)
      REPO_PATH="$2"
      shift 2
      ;;
    -out-path)
      OUT_PATH="$2"
      shift 2
      ;;
    -v)
      VERBOSE="true"
      shift
      ;;
    *)
      echo "Invalid argument: $1" >&2
      exit 1
      ;;
    esac
  done
}
#!/bin/sh

validate_repo() {
  if [ ! -d "$1/.git" ]; then
    echo "Error: '$1' is not a Git repo." >&2
    exit 1
  fi
}

# Params:
# 1. "$REPO_PATH"
# 2. "$REF"
#
# Called as: validate_git_ref "$REPO_PATH" "$REF"
validate_git_ref() {
  local repo_path="$1"
  local ref="$2"

  if [ -z "$ref" ]; then
    echo "Error: Missing git ref for validation" >&2
    exit 1
  fi

  if ! git -C "$repo_path" cat-file -e "$ref^{commit}" 2>/dev/null; then
    echo "Error: Invalid git ref '$ref'" >&2
    exit 1
  fi
}
#!/bin/sh

# Entrypoint: calls `parse_args`, `run_git_diff`

# Source all modules
# SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
# for file in "$SCRIPT_DIR/src"/*.sh; do
#   . "$file"
# done

main() {
  parse_args "$@"
  validate_repo "$REPO_PATH"
  resolve_defaults
  validate_git_ref "$REPO_PATH" "$END_REF"
  validate_git_ref "$REPO_PATH" "$START_REF"
  run_git_diff
  handle_output
}

main "$@"
